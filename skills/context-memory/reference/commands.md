

# Context Memory Commands Reference

Complete reference for all context memory operations.

## Command Invocation

All commands are executed via Python utilities:

```bash
python skills/context-memory/utils/memory_ops.py <operation> <args>
```

Or directly in Python:

```python
from memory_ops import recall_query, remember_file, get_memory_stats
```

## Capture Commands (REMEMBER)

### remember-file

Analyze and store file summary using Claude.

**Signature:**
```python
remember_file(file_path: str, note: Optional[str] = None) -> bool
```

**Usage:**
```bash
# Basic usage
python -c "from memory_ops import remember_file; remember_file('src/auth/jwt.ts')"

# With note
python -c "from memory_ops import remember_file; remember_file('src/auth/jwt.ts', 'Core JWT implementation')"
```

**What it captures:**
- File summary (generated by Claude)
- Main purpose and responsibility
- Complexity level (simple/moderate/complex)
- Key functions and their purposes
- Dependencies and imports
- Lines of code

**When to use:**
- After implementing new files
- When refactoring important files
- To document complex modules

### remember-pattern

Store a reusable code pattern.

**Signature:**
```python
remember_pattern(
    name: str,
    description: str,
    example_path: Optional[str] = None,
    category: Optional[str] = None
) -> bool
```

**Usage:**
```python
from memory_ops import remember_pattern

remember_pattern(
    "Repository Pattern",
    "All database access through repository classes with dependency injection",
    "src/repositories/user-repository.ts",
    "architecture"
)
```

**Categories:**
- `architecture` - Architectural patterns
- `testing` - Test patterns
- `error-handling` - Error handling approaches
- `api` - API design patterns
- `data` - Data modeling patterns

**When to use:**
- After establishing a new pattern
- When you want consistency across team
- To document "the way we do things"

### remember-decision

Store an architectural decision and its reasoning.

**Signature:**
```python
remember_decision(
    title: str,
    reasoning: str,
    context: Optional[str] = None,
    alternatives: Optional[str] = None
) -> bool
```

**Usage:**
```python
from memory_ops import remember_decision

remember_decision(
    "Using JWT for authentication",
    "Stateless authentication scales better for our microservices architecture",
    "Redesigning authentication system for v2.0",
    "Considered session-based auth but needed stateless approach"
)
```

**When to use:**
- Making architectural choices
- Changing established patterns
- After technical spike or POC
- When team debates approach

### remember-interaction

Store agent learning and interaction outcome.

**Signature:**
```python
remember_interaction(
    skill: str,
    context: str,
    action: str,
    outcome: str,
    learned: str,
    effectiveness: str = "successful"
) -> bool
```

**Usage:**
```python
from memory_ops import remember_interaction

remember_interaction(
    "dev",
    "User asked to implement JWT auth",
    "Implemented JWT middleware and token generation",
    "Tests passed, user approved implementation",
    "JWT pattern works well with our Express setup",
    "successful"
)
```

**Effectiveness levels:**
- `successful` - Achieved goal completely
- `partial` - Some success, some issues
- `unsuccessful` - Did not achieve goal

## Query Commands (RECALL)

### recall (Natural Language)

Full-text search across all context types.

**Signature:**
```python
recall_query(query: str, limit: int = 10) -> List[Dict]
```

**Usage:**
```python
from memory_ops import recall_query

results = recall_query("authentication", limit=10)
for r in results:
    print(f"{r['type']}: {r.get('path') or r.get('name')}")
```

**Returns:**
```python
[
    {
        'type': 'file',
        'path': 'src/auth/jwt.ts',
        'summary': 'JWT token generation and validation',
        'purpose': 'Handles authentication tokens',
        'complexity': 'moderate',
        'relevance': -0.234  # Lower is more relevant
    },
    {
        'type': 'pattern',
        'name': 'JWT Authentication',
        'description': 'Bearer token in Authorization header',
        'category': 'api',
        'usage_count': 5,
        'relevance': -0.456
    },
    {
        'type': 'decision',
        'title': 'JWT over sessions',
        'reasoning': 'Stateless auth for microservices',
        'decision_date': '2024-01-15',
        'relevance': -0.567
    }
]
```

**Query tips:**
- Use natural language: "how do we handle errors"
- Use technical terms: "jwt token validation"
- Use file names: "user repository"
- Combine terms: "authentication middleware"

### recall-file

Get detailed information about a specific file.

**Signature:**
```python
recall_file(path: str) -> Optional[Dict]
```

**Usage:**
```python
from memory_ops import recall_file

file_data = recall_file('src/auth/jwt.ts')
if file_data:
    print(f"Summary: {file_data['summary']}")
    print(f"Complexity: {file_data['complexity']}")
    print(f"Functions:")
    for func in file_data['functions']:
        print(f"  - {func['name']}: {func['purpose']}")
```

**Returns:**
```python
{
    'path': 'src/auth/jwt.ts',
    'language': 'typescript',
    'summary': 'JWT token generation and validation',
    'purpose': 'Handles authentication tokens',
    'complexity': 'moderate',
    'lines_of_code': 145,
    'last_analyzed': '2024-01-20 10:30:00',
    'dependencies': ['jsonwebtoken', 'bcrypt'],
    'functions': [
        {
            'name': 'generateToken',
            'signature': 'generateToken(userId: string): string',
            'purpose': 'Generate JWT token for authenticated user',
            'complexity': 'simple'
        },
        # ... more functions
    ]
}
```

### recall-pattern

Get detailed information about a specific pattern.

**Signature:**
```python
recall_pattern(name: str) -> Optional[Dict]
```

**Usage:**
```python
from memory_ops import recall_pattern

pattern = recall_pattern("Repository Pattern")
if pattern:
    print(f"Description: {pattern['description']}")
    print(f"Used in: {', '.join(pattern['examples'])}")
    print(f"Usage count: {pattern['usage_count']}")
```

### recall-decisions

Get architectural decisions, optionally filtered by timeframe.

**Signature:**
```python
recall_decisions(days: Optional[int] = None) -> List[Dict]
```

**Usage:**
```python
from memory_ops import recall_decisions

# All active decisions
all_decisions = recall_decisions()

# Decisions from last 30 days
recent = recall_decisions(days=30)

# Decisions from last 90 days
quarterly = recall_decisions(days=90)

for d in recent:
    print(f"{d['title']} - {d['decision_date']}")
    print(f"  Reasoning: {d['reasoning']}")
```

## Utility Commands

### memory-stats

Get database statistics.

**Signature:**
```python
get_memory_stats() -> Dict
```

**Usage:**
```python
from memory_ops import get_memory_stats

stats = get_memory_stats()
print(f"Files: {stats['files']}")
print(f"Patterns: {stats['patterns']}")
print(f"Decisions: {stats['decisions']}")
print(f"Interactions: {stats['interactions']}")
print(f"Database size: {stats['database_size_mb']:.2f} MB")
```

**Returns:**
```python
{
    'files': 127,
    'functions': 543,
    'patterns': 23,
    'decisions': 15,
    'interactions': 89,
    'git_context': 234,
    'database_size_mb': 2.45
}
```

## Automatic Capture (via Hooks)

Context is captured automatically when enabled:

### PostToolUse:Edit / PostToolUse:Write

Triggers: `capture-file-context.py`

**What's captured:**
- File summary and purpose
- Key functions
- Complexity analysis
- Dependencies

**Configuration:**
```bash
# Enable/disable in .env
PRISM_MEMORY_AUTO_CAPTURE=true
```

### PostToolUse:Bash (git commit)

Triggers: `capture-commit-context.py`

**What's captured:**
- Commit hash and message
- Files changed
- Commit summary (Claude-generated)
- Classification (feature/bug/refactoring)
- Author and date

## Command-Line Tools

### Initialize Database

```bash
python skills/context-memory/utils/init_db.py

# Rebuild database
python skills/context-memory/utils/init_db.py --rebuild

# Verify database
python skills/context-memory/utils/init_db.py --verify
```

### Test Claude API

```bash
python skills/context-memory/utils/claude_api.py
```

### Query from CLI

```bash
# Search
python -c "from memory_ops import recall_query; import json; print(json.dumps(recall_query('auth'), indent=2))"

# Stats
python -c "from memory_ops import get_memory_stats; import json; print(json.dumps(get_memory_stats(), indent=2))"
```

## Error Handling

**Database not found:**
```
❌ Database not found: .prism-memory.db
   Run: python skills/context-memory/utils/init_db.py
```

**API key missing:**
```
❌ ANTHROPIC_API_KEY not found in environment
   Please add to .env file:
   ANTHROPIC_API_KEY=your-key-here
```

**Query returns empty:**
```python
results = recall_query("nonexistent")
if not results:
    print("No results found. Try broader search terms.")
```

## Performance Considerations

**Indexing:**
- FTS5 indexes on files, patterns, decisions
- Fast full-text search (<100ms for most queries)

**Analysis:**
- Claude API calls limited by rate limits
- File analysis cached in database
- Reanalysis only on file changes

**Storage:**
- Typical project: 1-5 MB database
- 100+ files: ~2 MB
- 1000+ files: ~20 MB

## Best Practices

1. **Let hooks capture automatically** - Most context captured without manual effort

2. **Store patterns explicitly** - Document team conventions as patterns

3. **Record important decisions** - Make architectural choices searchable

4. **Query before implementing** - Check for existing patterns/solutions

5. **Use timeframes for decisions** - Recent decisions more relevant

6. **Keep queries focused** - Start broad, narrow with specific terms

7. **Review stats periodically** - Understand what's being captured
